pipeline {
  agent any

  tools {
    jdk 'java17016'
    maven 'maven399'
  }

  environment {
    // ===== Proyecto =====
    PROJECT_NAME = 'farmatodo'
    BUILD_TAG    = "${BUILD_NUMBER}"

    // ===== GCP Configuration =====
    GCP_PROJECT_ID = 'planar-momentum-469121-n0'
    REGION         = 'us-central1'
    ZONE           = 'us-central1-a'

    // ===== Artifact Registry =====
    AR_HOST        = "${REGION}-docker.pkg.dev"
    REPOSITORY     = 'farmatodo-repo'

    // ===== Compute Engine =====
    VM_INSTANCE_NAME = 'farmatodo-app-vm'
    VM_MACHINE_TYPE  = 'e2-standard-4'  // 4 vCPUs, 16 GB RAM (ajustar según necesidades)
    VM_BOOT_DISK_SIZE = '100GB'
    VM_IMAGE_FAMILY   = 'ubuntu-2204-lts'
    VM_IMAGE_PROJECT  = 'ubuntu-os-cloud'

    // ===== Servicios a construir =====
    SERVICES = 'config-server,api-gateway,client-service,token-service,product-service,cart-service,order-service'

    // ===== SonarQube =====
    SONAR_SCANNER_HOME = tool 'sonar7'
  }

  options {
    timestamps()
    timeout(time: 60, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  stages {

    // 1) Checkout
    stage('Checkout') {
      steps {
        echo "📦 Clonando repositorio desde GitHub..."
        checkout scmGit(
          branches: [[name: '*/main']],
          extensions: [],
          userRemoteConfigs: [[
            credentialsId: 'jenkins-gcp',
            url: 'https://github.com/santgodev/farmatodo-backend.git'
          ]]
        )
      }
    }

    // 2) Build All Services
    stage('Build All Services') {
      parallel {
        stage('Build Config Server') {
          steps {
            dir('config-server') {
              echo "🧱 Compilando config-server..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build API Gateway') {
          steps {
            dir('api-gateway') {
              echo "🧱 Compilando api-gateway..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build Client Service') {
          steps {
            dir('client-service') {
              echo "🧱 Compilando client-service..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build Token Service') {
          steps {
            dir('token-service') {
              echo "🧱 Compilando token-service..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build Product Service') {
          steps {
            dir('product-service') {
              echo "🧱 Compilando product-service..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build Cart Service') {
          steps {
            dir('cart-service') {
              echo "🧱 Compilando cart-service..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
        stage('Build Order Service') {
          steps {
            dir('order-service') {
              echo "🧱 Compilando order-service..."
              sh "mvn -q -Dstyle.color=always clean package -DskipTests=true"
            }
          }
        }
      }
    }

    // 3) Build Docker Images
    stage('Build Docker Images') {
      steps {
        script {
          echo "🐳 Construyendo imágenes Docker para todos los servicios..."
          def servicesList = env.SERVICES.split(',')

          servicesList.each { service ->
            dir(service.trim()) {
              echo "🐳 Construyendo imagen para ${service}..."
              sh "docker build -t ${PROJECT_NAME}/${service}:${BUILD_TAG} -t ${PROJECT_NAME}/${service}:latest ."
            }
          }
        }
      }
    }

    // 4) Push Images to Artifact Registry
    stage('Push to Artifact Registry') {
      steps {
        echo "☁️ Autenticando en GCP y empujando imágenes a Artifact Registry..."
        withCredentials([file(credentialsId: 'gcp-credentials', variable: 'gcpCred')]) {
          withEnv(["GOOGLE_APPLICATION_CREDENTIALS=$gcpCred"]) {
            script {
              sh """
                echo "🔐 Activando cuenta de servicio..."
                gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
                gcloud config set project "$GCP_PROJECT_ID"

                echo "🧭 Configurando credenciales Docker para Artifact Registry..."
                gcloud auth configure-docker "${AR_HOST}" --quiet

                echo "🏷️ Creando repositorio si no existe..."
                if ! gcloud artifacts repositories describe "$REPOSITORY" --location="$REGION" --project="$GCP_PROJECT_ID" >/dev/null 2>&1 ; then
                  gcloud artifacts repositories create "$REPOSITORY" \
                    --repository-format=docker \
                    --location="$REGION" \
                    --description="Docker repo for Farmatodo microservices" \
                    --project="$GCP_PROJECT_ID"
                fi
              """

              // Push each service
              def servicesList = env.SERVICES.split(',')
              servicesList.each { service ->
                def serviceName = service.trim()
                def fullImageName = "${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/${serviceName}:${BUILD_TAG}"
                def latestImageName = "${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/${serviceName}:latest"

                sh """
                  echo "🏷️ Etiquetando ${serviceName}..."
                  docker tag ${PROJECT_NAME}/${serviceName}:${BUILD_TAG} ${fullImageName}
                  docker tag ${PROJECT_NAME}/${serviceName}:latest ${latestImageName}

                  echo "📤 Pushing ${serviceName}..."
                  docker push ${fullImageName}
                  docker push ${latestImageName}
                """
              }
            }
          }
        }
      }
    }

    // 5) Create/Update GCE VM Instance
    stage('Setup GCE VM') {
      steps {
        echo "🖥️ Configurando VM en Google Compute Engine..."
        withCredentials([file(credentialsId: 'gcp-credentials', variable: 'gcpCred')]) {
          withEnv(["GOOGLE_APPLICATION_CREDENTIALS=$gcpCred"]) {
            sh """
              gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
              gcloud config set project "$GCP_PROJECT_ID"

              # Verificar si la VM ya existe
              if gcloud compute instances describe "$VM_INSTANCE_NAME" --zone="$ZONE" >/dev/null 2>&1 ; then
                echo "✅ VM ya existe. Verificando estado..."
                VM_STATUS=\$(gcloud compute instances describe "$VM_INSTANCE_NAME" --zone="$ZONE" --format="value(status)")

                if [ "\$VM_STATUS" != "RUNNING" ]; then
                  echo "🚀 Iniciando VM..."
                  gcloud compute instances start "$VM_INSTANCE_NAME" --zone="$ZONE"
                fi
              else
                echo "🆕 Creando nueva VM..."
                gcloud compute instances create "$VM_INSTANCE_NAME" \
                  --zone="$ZONE" \
                  --machine-type="$VM_MACHINE_TYPE" \
                  --boot-disk-size="$VM_BOOT_DISK_SIZE" \
                  --image-family="$VM_IMAGE_FAMILY" \
                  --image-project="$VM_IMAGE_PROJECT" \
                  --tags=farmatodo,http-server,https-server \
                  --metadata=startup-script='#!/bin/bash
                    apt-get update
                    apt-get install -y docker.io docker-compose
                    systemctl start docker
                    systemctl enable docker
                    usermod -aG docker \$USER
                  '

                echo "⏳ Esperando a que la VM esté lista..."
                sleep 60
              fi

              # Crear reglas de firewall si no existen
              echo "🔥 Configurando reglas de firewall..."

              # Permitir acceso a los puertos de los servicios
              if ! gcloud compute firewall-rules describe farmatodo-allow-services --project="$GCP_PROJECT_ID" >/dev/null 2>&1 ; then
                gcloud compute firewall-rules create farmatodo-allow-services \
                  --allow=tcp:8080,tcp:8081,tcp:8082,tcp:8083,tcp:8084,tcp:8085,tcp:8888,tcp:9090 \
                  --source-ranges=0.0.0.0/0 \
                  --target-tags=farmatodo \
                  --description="Allow access to Farmatodo services"
              fi

              # Permitir acceso a PostgreSQL (solo para debugging, no recomendado en producción)
              if ! gcloud compute firewall-rules describe farmatodo-allow-postgres --project="$GCP_PROJECT_ID" >/dev/null 2>&1 ; then
                gcloud compute firewall-rules create farmatodo-allow-postgres \
                  --allow=tcp:5432,tcp:5433,tcp:5434,tcp:5435,tcp:5436 \
                  --source-ranges=0.0.0.0/0 \
                  --target-tags=farmatodo \
                  --description="Allow access to PostgreSQL databases (dev only)"
              fi
            """
          }
        }
      }
    }

    // 6) Deploy to GCE VM with Docker Compose
    stage('Deploy to GCE') {
      steps {
        echo "🚀 Desplegando aplicación en GCE con Docker Compose..."
        withCredentials([file(credentialsId: 'gcp-credentials', variable: 'gcpCred')]) {
          withEnv(["GOOGLE_APPLICATION_CREDENTIALS=$gcpCred"]) {
            script {
              sh """
                gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
                gcloud config set project "$GCP_PROJECT_ID"

                # Preparar docker-compose.prod.yml con las imágenes de Artifact Registry
                cat > docker-compose.prod.yml <<'COMPOSE_EOF'
version: '3.8'

services:
  config-server:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/config-server:latest
    container_name: farmatodo-config-server
    environment:
      SPRING_APPLICATION_NAME: config-server
      SERVER_PORT: 8888
      SPRING_CLOUD_CONFIG_SERVER_GIT_URI: https://github.com/santgodev/farmatodo-config-service
      SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL: master
      SPRING_CLOUD_CONFIG_SERVER_GIT_CLONE_ON_START: "true"
      SPRING_CLOUD_CONFIG_SERVER_GIT_SKIP_SSL_VALIDATION: "true"
      SPRING_CLOUD_CONFIG_SERVER_GIT_TIMEOUT: 30
    ports:
      - "8888:8888"
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:8888/actuator/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 40s
    restart: unless-stopped

  client-db:
    image: postgres:16-alpine
    container_name: farmatodo-client-db
    environment:
      POSTGRES_DB: clientdb
      POSTGRES_USER: clientuser
      POSTGRES_PASSWORD: clientpass
    ports:
      - "5432:5432"
    volumes:
      - client-db-data:/var/lib/postgresql/data
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U clientuser -d clientdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  token-db:
    image: postgres:16-alpine
    container_name: farmatodo-token-db
    environment:
      POSTGRES_DB: tokendb
      POSTGRES_USER: tokenuser
      POSTGRES_PASSWORD: tokenpass
    ports:
      - "5433:5432"
    volumes:
      - token-db-data:/var/lib/postgresql/data
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U tokenuser -d tokendb"]
      interval: 10s
      timeout: 5s
      retries: 5

  client-service:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/client-service:latest
    container_name: farmatodo-client-service
    environment:
      SPRING_APPLICATION_NAME: client-service
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SPRING_DATASOURCE_URL: jdbc:postgresql://client-db:5432/clientdb
      SPRING_DATASOURCE_USERNAME: clientuser
      SPRING_DATASOURCE_PASSWORD: clientpass
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: "true"
      SERVER_PORT: 8081
      API_KEY: client-service-api-key-change-in-production
    ports:
      - "8081:8081"
    depends_on:
      config-server:
        condition: service_healthy
      client-db:
        condition: service_healthy
    networks:
      - farmatodo-network
    restart: unless-stopped

  token-service:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/token-service:latest
    container_name: farmatodo-token-service
    environment:
      SPRING_APPLICATION_NAME: token-service
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SPRING_DATASOURCE_URL: jdbc:postgresql://token-db:5432/tokendb
      SPRING_DATASOURCE_USERNAME: tokenuser
      SPRING_DATASOURCE_PASSWORD: tokenpass
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: "true"
      SERVER_PORT: 8082
      API_KEY: your-secret-api-key-change-in-production
      ENCRYPTION_SECRET_KEY: MySecretKey1234567890123456789012
      TOKEN_REJECTIONPROBABILITY: 0.3
      PAYMENT_REJECTIONPROBABILITY: 0.3
      PAYMENT_RETRYCOUNT: 3
      EMAIL_ENABLED: "false"
      EMAIL_FROM: noreply@farmatodo.com
    ports:
      - "8082:8082"
    depends_on:
      config-server:
        condition: service_healthy
      token-db:
        condition: service_healthy
    networks:
      - farmatodo-network
    restart: unless-stopped

  product-db:
    image: postgres:16-alpine
    container_name: farmatodo-product-db
    environment:
      POSTGRES_DB: productdb
      POSTGRES_USER: productuser
      POSTGRES_PASSWORD: productpass
    ports:
      - "5434:5432"
    volumes:
      - product-db-data:/var/lib/postgresql/data
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U productuser -d productdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  cart-db:
    image: postgres:16-alpine
    container_name: farmatodo-cart-db
    environment:
      POSTGRES_DB: cartdb
      POSTGRES_USER: cartuser
      POSTGRES_PASSWORD: cartpass
    ports:
      - "5435:5432"
    volumes:
      - cart-db-data:/var/lib/postgresql/data
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cartuser -d cartdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  product-service:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/product-service:latest
    container_name: farmatodo-product-service
    environment:
      SPRING_APPLICATION_NAME: product-service
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SPRING_DATASOURCE_URL: jdbc:postgresql://product-db:5432/productdb
      SPRING_DATASOURCE_USERNAME: productuser
      SPRING_DATASOURCE_PASSWORD: productpass
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: "true"
      SERVER_PORT: 8083
      API_KEY: product-service-api-key-change-in-production
      PRODUCT_MINSTOCK: 0
    ports:
      - "8083:8083"
    depends_on:
      config-server:
        condition: service_healthy
      product-db:
        condition: service_healthy
    networks:
      - farmatodo-network
    restart: unless-stopped

  cart-service:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/cart-service:latest
    container_name: farmatodo-cart-service
    environment:
      SPRING_APPLICATION_NAME: cart-service
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SPRING_DATASOURCE_URL: jdbc:postgresql://cart-db:5432/cartdb
      SPRING_DATASOURCE_USERNAME: cartuser
      SPRING_DATASOURCE_PASSWORD: cartpass
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: "true"
      SERVER_PORT: 8084
      API_KEY: cart-service-api-key-change-in-production
      SERVICES_PRODUCT_URL: http://product-service:8083
      SERVICES_PRODUCT_APIKEY: product-service-api-key-change-in-production
    ports:
      - "8084:8084"
    depends_on:
      config-server:
        condition: service_healthy
      cart-db:
        condition: service_healthy
      product-service:
        condition: service_started
    networks:
      - farmatodo-network
    restart: unless-stopped

  order-db:
    image: postgres:16-alpine
    container_name: farmatodo-order-db
    environment:
      POSTGRES_DB: orderdb
      POSTGRES_USER: orderuser
      POSTGRES_PASSWORD: orderpass
    ports:
      - "5436:5432"
    volumes:
      - order-db-data:/var/lib/postgresql/data
    networks:
      - farmatodo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U orderuser -d orderdb"]
      interval: 10s
      timeout: 5s
      retries: 5

  order-service:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/order-service:latest
    container_name: farmatodo-order-service
    environment:
      SPRING_APPLICATION_NAME: order-service
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SPRING_DATASOURCE_URL: jdbc:postgresql://order-db:5432/orderdb
      SPRING_DATASOURCE_USERNAME: orderuser
      SPRING_DATASOURCE_PASSWORD: orderpass
      SPRING_JPA_HIBERNATE_DDL_AUTO: update
      SPRING_JPA_SHOW_SQL: "true"
      SERVER_PORT: 8085
      API_KEY: order-service-api-key-change-in-production
      PAYMENT_REJECTIONPROBABILITY: 0.3
      PAYMENT_RETRYCOUNT: 3
      SERVICES_CLIENT_URL: http://client-service:8081
      SERVICES_CLIENT_APIKEY: client-service-api-key-change-in-production
      SERVICES_TOKEN_URL: http://token-service:8082
      SERVICES_TOKEN_APIKEY: your-secret-api-key-change-in-production
      SERVICES_PRODUCT_URL: http://product-service:8083
      SERVICES_PRODUCT_APIKEY: product-service-api-key-change-in-production
      SERVICES_CART-SERVICE_URL: http://cart-service:8084
      SERVICES_CART-SERVICE_API-KEY: cart-service-api-key-change-in-production
      EMAIL_ENABLED: "false"
      EMAIL_FROM: noreply@farmatodo.com
    ports:
      - "8085:8085"
    depends_on:
      config-server:
        condition: service_healthy
      order-db:
        condition: service_healthy
      client-service:
        condition: service_started
      token-service:
        condition: service_started
      cart-service:
        condition: service_started
    networks:
      - farmatodo-network
    restart: unless-stopped

  api-gateway:
    image: ${AR_HOST}/${GCP_PROJECT_ID}/${REPOSITORY}/api-gateway:latest
    container_name: farmatodo-api-gateway
    environment:
      SPRING_APPLICATION_NAME: api-gateway
      SPRING_PROFILES_ACTIVE: dev
      SPRING_CONFIG_IMPORT: "optional:configserver:http://config-server:8888"
      SPRING_CLOUD_CONFIG_FAIL_FAST: "false"
      SPRING_CLOUD_CONFIG_URI: http://config-server:8888
      SERVER_PORT: 9090
      CLIENT_SERVICE_URL: http://client-service:8081
      TOKEN_SERVICE_URL: http://token-service:8082
      PRODUCT_SERVICE_URL: http://product-service:8083
      CART_SERVICE_URL: http://cart-service:8084
      ORDER_SERVICE_URL: http://order-service:8085
    ports:
      - "9090:9090"
    depends_on:
      config-server:
        condition: service_healthy
      client-service:
        condition: service_started
      token-service:
        condition: service_started
      product-service:
        condition: service_started
      cart-service:
        condition: service_started
      order-service:
        condition: service_started
    networks:
      - farmatodo-network
    restart: unless-stopped

networks:
  farmatodo-network:
    driver: bridge

volumes:
  client-db-data:
  token-db-data:
  product-db-data:
  cart-db-data:
  order-db-data:
COMPOSE_EOF

                # Copiar archivos a la VM
                echo "📂 Copiando archivos a la VM..."
                gcloud compute scp docker-compose.prod.yml "$VM_INSTANCE_NAME":~/docker-compose.yml --zone="$ZONE"

                # Ejecutar comandos en la VM
                echo "🚀 Desplegando aplicación en la VM..."
                gcloud compute ssh "$VM_INSTANCE_NAME" --zone="$ZONE" --command="
                  # Autenticar Docker con Artifact Registry
                  gcloud auth configure-docker ${AR_HOST} --quiet

                  # Detener contenedores existentes
                  docker-compose down || true

                  # Limpiar imágenes antiguas
                  docker image prune -f

                  # Iniciar servicios con docker-compose
                  docker-compose up -d

                  # Esperar a que los servicios estén listos
                  echo '⏳ Esperando a que los servicios estén listos...'
                  sleep 90

                  # Mostrar estado de los contenedores
                  docker-compose ps
                "

                # Obtener IP externa de la VM
                VM_EXTERNAL_IP=\$(gcloud compute instances describe "$VM_INSTANCE_NAME" --zone="$ZONE" --format="get(networkInterfaces[0].accessConfigs[0].natIP)")

                echo ""
                echo "=========================================="
                echo "✅ DESPLIEGUE COMPLETADO"
                echo "=========================================="
                echo "VM External IP: \$VM_EXTERNAL_IP"
                echo ""
                echo "📍 URLs de los Servicios:"
                echo "  Config Server:  http://\${VM_EXTERNAL_IP}:8888/actuator/health"
                echo "  API Gateway:    http://\${VM_EXTERNAL_IP}:9090/api/gateway/health"
                echo "  Client Service: http://\${VM_EXTERNAL_IP}:8081/api/clients/health"
                echo "  Token Service:  http://\${VM_EXTERNAL_IP}:8082/api/tokens/health"
                echo "  Product Service: http://\${VM_EXTERNAL_IP}:8083/products/health"
                echo "  Cart Service:   http://\${VM_EXTERNAL_IP}:8084/carts/health"
                echo "  Order Service:  http://\${VM_EXTERNAL_IP}:8085/orders/ping"
                echo ""
                echo "📍 Bases de Datos (PostgreSQL):"
                echo "  Client DB:  \${VM_EXTERNAL_IP}:5432"
                echo "  Token DB:   \${VM_EXTERNAL_IP}:5433"
                echo "  Product DB: \${VM_EXTERNAL_IP}:5434"
                echo "  Cart DB:    \${VM_EXTERNAL_IP}:5435"
                echo "  Order DB:   \${VM_EXTERNAL_IP}:5436"
                echo "=========================================="

                # Guardar URLs en archivo
                echo "\$VM_EXTERNAL_IP" > vm-external-ip.txt
              """
            }
          }
        }
      }
    }

    // 7) Health Checks
    stage('Health Checks') {
      steps {
        echo "🏥 Verificando salud de los servicios..."
        withCredentials([file(credentialsId: 'gcp-credentials', variable: 'gcpCred')]) {
          withEnv(["GOOGLE_APPLICATION_CREDENTIALS=$gcpCred"]) {
            script {
              sh """
                gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
                gcloud config set project "$GCP_PROJECT_ID"

                VM_EXTERNAL_IP=\$(cat vm-external-ip.txt)

                # Función para verificar salud de un servicio
                check_health() {
                  local service_name=\$1
                  local url=\$2
                  local max_retries=15
                  local retry_delay=10

                  echo "Verificando \$service_name..."
                  for i in \$(seq 1 \$max_retries); do
                    if curl -f -s \$url > /dev/null 2>&1; then
                      echo "✅ \$service_name está saludable"
                      return 0
                    else
                      echo "⏳ Intento \$i/\$max_retries - \$service_name aún no está listo..."
                      sleep \$retry_delay
                    fi
                  done

                  echo "⚠️ \$service_name no respondió después de \$max_retries intentos"
                  return 1
                }

                # Verificar cada servicio
                check_health "Config Server" "http://\${VM_EXTERNAL_IP}:8888/actuator/health"
                check_health "API Gateway" "http://\${VM_EXTERNAL_IP}:9090/api/gateway/health"
                check_health "Client Service" "http://\${VM_EXTERNAL_IP}:8081/api/clients/health"
                check_health "Token Service" "http://\${VM_EXTERNAL_IP}:8082/api/tokens/health"
                check_health "Product Service" "http://\${VM_EXTERNAL_IP}:8083/products/health"
                check_health "Cart Service" "http://\${VM_EXTERNAL_IP}:8084/carts/health"
                check_health "Order Service" "http://\${VM_EXTERNAL_IP}:8085/orders/ping"

                echo ""
                echo "✅ Verificación de salud completada"
              """
            }
          }
        }
      }
    }
  }

  post {
    success {
      script {
        def vmIp = readFile('vm-external-ip.txt').trim()
        echo """
╔════════════════════════════════════════════════════════════════╗
║                   ✅ DESPLIEGUE EXITOSO                        ║
╚════════════════════════════════════════════════════════════════╝

🌐 IP Pública de la VM: ${vmIp}

📍 URLs Públicas de los Servicios:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  🔧 Config Server:   http://${vmIp}:8888/actuator/health
  🚪 API Gateway:     http://${vmIp}:9090/api/gateway/health
  👤 Client Service:  http://${vmIp}:8081/api/clients/health
  🔑 Token Service:   http://${vmIp}:8082/api/tokens/health
  📦 Product Service: http://${vmIp}:8083/products/health
  🛒 Cart Service:    http://${vmIp}:8084/carts/health
  📋 Order Service:   http://${vmIp}:8085/orders/ping

📊 Bases de Datos PostgreSQL:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  🗄️ Client DB:  ${vmIp}:5432 (clientdb/clientuser/clientpass)
  🗄️ Token DB:   ${vmIp}:5433 (tokendb/tokenuser/tokenpass)
  🗄️ Product DB: ${vmIp}:5434 (productdb/productuser/productpass)
  🗄️ Cart DB:    ${vmIp}:5435 (cartdb/cartuser/cartpass)
  🗄️ Order DB:   ${vmIp}:5436 (orderdb/orderuser/orderpass)

🔨 Comandos Útiles:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Ver logs:         gcloud compute ssh ${VM_INSTANCE_NAME} --zone=${ZONE} --command="docker-compose logs -f"
  Ver contenedores: gcloud compute ssh ${VM_INSTANCE_NAME} --zone=${ZONE} --command="docker-compose ps"
  Reiniciar todo:   gcloud compute ssh ${VM_INSTANCE_NAME} --zone=${ZONE} --command="docker-compose restart"
  Detener todo:     gcloud compute ssh ${VM_INSTANCE_NAME} --zone=${ZONE} --command="docker-compose down"

⚙️ Gestión de la VM:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Detener VM:  gcloud compute instances stop ${VM_INSTANCE_NAME} --zone=${ZONE}
  Iniciar VM:  gcloud compute instances start ${VM_INSTANCE_NAME} --zone=${ZONE}
  SSH a VM:    gcloud compute ssh ${VM_INSTANCE_NAME} --zone=${ZONE}

╔════════════════════════════════════════════════════════════════╗
║  Build Number: ${BUILD_NUMBER}
║  Duration: ${currentBuild.durationString}
╚════════════════════════════════════════════════════════════════╝
        """
      }
    }
    failure {
      echo """
╔════════════════════════════════════════════════════════════════╗
║                     ❌ DESPLIEGUE FALLIDO                      ║
╚════════════════════════════════════════════════════════════════╝

Build Number: ${BUILD_NUMBER}
Duration: ${currentBuild.durationString}

Por favor, revisa los logs para más detalles.
      """
    }
    always {
      echo "🧹 Limpieza..."
      archiveArtifacts artifacts: "**/target/*.jar", allowEmptyArchive: true, fingerprint: true
      archiveArtifacts artifacts: "vm-external-ip.txt", allowEmptyArchive: true
      archiveArtifacts artifacts: "docker-compose.prod.yml", allowEmptyArchive: true

      // Limpiar imágenes Docker locales para liberar espacio
      sh 'docker system prune -f || true'
    }
  }
}
